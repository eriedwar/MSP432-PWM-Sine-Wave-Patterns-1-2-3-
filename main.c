#include "msp.h"
#include "lcdLib_432.h"

// Gloabal variables
int tic = 0;
int firstPattern[] = {30000,39000,47400,54000,58800,60000,58800,54000,47400,39000,30000,21000,12600,6000,1200,1,1200,6000,12600,21000}; //size of 20
int secondPattern[20];
int thirdPattern[] = {30000, 47400,39000,54000,60000,58800,47400,54000,39000,21000,30000,12600,1200,6000,1,6000,1200,12600,30000,21000}; // size of 20

// Function declarations
void PWMINIT(void);
void GPIOINIT(void);
void sineWave(void);
void randLEDWave(void);
void noisyWave(void);
void fillPattern(void);
void clearPWM(void);

void sineWave(void){
    int pattern[] = {30000,39000,47400,54000,58800,60000,58800,54000,47400,39000,30000,21000,12600,6000,1200,1,1200,6000,12600,21000};
        int size = sizeof(pattern)/sizeof(int); // get the size of the pattern array
        int i = 0; // Declare and initialize a counter variable i to 0
        for(i = 0; i < size; i++) { // loop through the pattern array
            __delay_cycles(100000); // Add a delay of 100000 cycles
            if(i < 4) { // If i is less than 4
                TIMER_A0->CCR[1+i] = pattern[i]; // set PWM duty cycle for pins P2.4, P2.5, P2.6, and P2.7
            } else {
                TIMER_A2->CCR[1] = pattern[i]; // set PWM duty cycle for pin P5.6
                if(i % 5 == 4) { // cycle through P2.4, P2.5, P2.6, and P2.7 every 5th iteration
                    TIMER_A0->CCR[1] = pattern[i-4];
                    TIMER_A0->CCR[2] = pattern[i-3];
                    TIMER_A0->CCR[3] = pattern[i-2];
                    TIMER_A0->CCR[4] = pattern[i-1];
                }
            }
        }
    }
void fillPattern(void){ // This function fills the array "secondPattern" with 20 random integer values
    int i = 0;
    for(; i < 20; i++){
        secondPattern[i] = rand(); // "rand()" function to generate random values
    }
}
// This function is named patternTwo and does not return any value
void randLEDWave(void){
    fillPattern(); // Calls fillPattern function to fill an array with data
    int i = 0; // Declare and initialize a counter variable i to 0
    while(i < sizeof(thirdPattern)/sizeof(int)){ // Loop while i is less than the size of the thirdPattern array divided by the size of int data type
        __delay_cycles(1500000); // Add a delay of 500000 cycles
        if(i < 4){ // If i is less than 4
            TIMER_A0->CCR[i+1] = secondPattern[i]; // ("Used to randomize the array") Set the Capture/Compare register i+1 of Timer A0 to the i-th value of the secondPattern array
        }
        else{ // Otherwise (i is greater than or equal to 4)
            TIMER_A0->CCR[(i%4)+1] = secondPattern[i]; // ("Used to randomize the array") Set the Capture/Compare register (i%4)+1 of Timer A0 to the i-th value of the secondPattern array
            if(i % 4 == 3){ // If i modulo 4 is equal to 3
                TIMER_A2->CCR[1] = secondPattern[i]; // ("Used to randomize the array") Set the Capture/Compare register 1 of Timer A2 to the i-th value of the secondPattern array
            }
        }
        i++; // Increment the counter i by 1
    }
}

void noisyWave(void){
    int i = 0;  // Initialize a loop counter variable to 0
    while(i < 20){  // Start a loop that runs 20 times
        __delay_cycles(250000);  // Wait for 100000 cycles
        if(i < 4){  // If i is less than 4,
            TIMER_A0->CCR[i+1] = thirdPattern[i];  // assign thirdPattern[i] to the appropriate TIMER_A0->CCR element
        }
        else{  // Otherwise,
            TIMER_A0->CCR[(i%4)+1] = thirdPattern[i];  // assign thirdPattern[i] to the appropriate TIMER_A0->CCR element based on i modulo 4
            if(i % 4 == 3){  // If i is a multiple of 4 (i.e. 3, 7, 11, 15, or 19),
                TIMER_A2->CCR[1] = thirdPattern[i];  // assign thirdPattern[i] to TIMER_A2->CCR[1]
            }
        }
        i++;  // Increment the loop counter variable
    }
}

void PORT5_IRQHandler(void){
uint8_t result = P5->IFG; // Capture the interrupt flags of Port 5
if(P5 -> IFG & BIT0){ // If the interrupt was generated by P5.0 pin
    lcdClear(); // Clear the LCD screen
    lcdSetText("Sine Wave",0,0); // Set the text "Pattern One" on the first line of the LCD
    sineWave(); // Call the function to display pattern one
    tic = 1;  // Set the flag tic to 1 indicating that Pattern One was selected
}
    if(P5 -> IFG & BIT1){ // If the interrupt was generated by P5.1 pin
        lcdClear(); // Clear the LCD screen
        lcdSetText("Random LED Wave",0,0); // Set the text "Pattern Two" on the first line of the LCD
        randLEDWave(); // Call the function to display pattern two
        tic = 2; // Set the flag tic to 2 indicating that Pattern Two was selected
    }
        if(P5 -> IFG & BIT2){ // If the interrupt was generated by P5.2 pin
                    lcdClear(); // Clear the LCD screen
                    lcdSetText("Noisy Wave",0,0); // Set the text "Pattern Three" on the first line of the LCD
                    noisyWave(); // Call the function to display pattern three
                    tic = 3; // Set the flag tic to 3 indicating that Pattern Three was selected
                }
        P5->IFG &= ~(result); // Clear the interrupt flags of Port 5
        }

void clearPWM(void){
    TIMER_A0->CCR[1] = 1 - 1; //set pwm value for P2.4 as 0
    TIMER_A0->CCR[2] = 1 - 1; //set pwm value for P2.5 as 0
    TIMER_A0->CCR[3] = 1 - 1; //set pwm value for P2.6 as 0
    TIMER_A0->CCR[4] = 1 - 1; //set pwm value for P2.7 as 0
    TIMER_A2->CCR[1] = 1 - 1; //set pwm value for P5.6 as 0
}
void GPIOINIT(void){
    //Pull-down setup for P5.0 P5.1 P5.2
    P5->DIR &= ~(BIT0 | BIT1 | BIT2); // Set direction of P5.0, P5.1, and P5.2 as input.
    P5->OUT &= ~(BIT0 | BIT1 | BIT2); // Set output of P5.0, P5.1, and P5.2 as 0.
    P5->REN |= (BIT0 | BIT1 | BIT2); // Enable pull-down resistors for P5.0, P5.1, and P5.2.
    P5->SEL0 &= ~(BIT0 | BIT1 | BIT2); // Select P5.0, P5.1, and P5.2 as GPIO.
    P5->SEL1 &= ~(BIT0 | BIT1 | BIT2);


    P5->IE |= (BIT0 | BIT1 | BIT2); // Enable interrupts for P5.0, P5.1, and P5.2.
    P5->IES &= ~(BIT0|BIT1 | BIT2); // Set interrupt to trigger on the rising edge of P5.0, P5.1, and P5.2.
    P5->IFG &= ~(BIT0|BIT1 | BIT2); // Clear the interrupt flags for P5.0, P5.1, and P5.2.


    NVIC->ISER[1] = 1 << ((PORT5_IRQn) & 31); // Enable the interrupt for Port 5.
    __enable_irq(); // Enable global interrupts.
}
void PWMINIT(void){
    //Enable P2.4 - P2.7 as PWM channels
    P2->DIR |= (BIT4|BIT5|BIT6|BIT7);
    P2->SEL0 |= (BIT4|BIT5|BIT6|BIT7);
    P2->SEL1 &= ~(BIT4|BIT5|BIT6|BIT7);
    //Enable P5.6 as PWM Channel
    P5->DIR |= (BIT6);
    P5->SEL0 |= (BIT6);
    P5->SEL1 &= ~(BIT6);
    //Set timer as a System clock, mode as up, and clear previous configuration
    TIMER_A0->CTL |= TIMER_A_CTL_SSEL__SMCLK |
                     TIMER_A_CTL_MC__UP|
                     TIMER_A_CTL_CLR;
    //frequency for each PWM channel
    TIMER_A0->CCR[0] = 60000 - 1; // Set max frequency as 50 Hz
    TIMER_A0->CCR[1] = 1 - 1; //2.4
    TIMER_A0->CCR[2] = 1 - 1; //2.5
    TIMER_A0->CCR[3] = 1 - 1;//2.6
    TIMER_A0->CCR[4] = 1 - 1;//2.7
    //Output for each PWM Channel
    TIMER_A0->CCTL[1] = TIMER_A_CCTLN_OUTMOD_7; //enable reset/set mode
    TIMER_A0->CCTL[2] = TIMER_A_CCTLN_OUTMOD_7;
    TIMER_A0->CCTL[3] = TIMER_A_CCTLN_OUTMOD_7;
    TIMER_A0->CCTL[4] = TIMER_A_CCTLN_OUTMOD_7;
    //P5.6 PWM Set up
    TIMER_A2->CCR[0] = 60000 - 1;
    //PWM channel frequency
    TIMER_A2->CCR[1] = 1 - 1;
    TIMER_A2->CTL |= TIMER_A_CTL_SSEL__SMCLK |
                     TIMER_A_CTL_MC__UP|
                     TIMER_A_CTL_CLR;
    TIMER_A2->CCTL[1] = TIMER_A_CCTLN_OUTMOD_7;
}


// Main function
void main(void){

WDT_A->CTL = WDT_A_CTL_PW | WDT_A_CTL_HOLD;     // stop watchdog timer

// Initialize GPIO pins
GPIOINIT();

// Initialize PWM
PWMINIT();

// Initialize LCD
lcdInit();
lcdClear();

while(1){
    // Check if button 1 is pressed
    if(P5 -> IFG & BIT0){
        tic = 1;
    }
    // Check if button 2 is pressed
        if(P5 -> IFG & BIT1){
            tic = 2;
        }
        // Check if button 3 is pressed
            if(P5 -> IFG & BIT2){
                    tic = 3;
                }

    // Execute appropriate pattern based on button press
    if(tic == 1){
        lcdClear();
        lcdSetText("Sine Wave",0,0);
        sineWave();
    }
        if(tic == 2){
            lcdClear();
            lcdSetText("Random LED Wave",0,0);
            randLEDWave();
        }
            if(tic == 3){
                lcdClear();
                lcdSetText("Noisy Wave",0,0);
                noisyWave();
            }
            clearPWM(); // Clear PWM settings
        }
    }
